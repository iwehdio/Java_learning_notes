## 链表

- 递归思维：
  - 给递归函数一个明确的定义，包括参数和返回值。
  - 给递归函数一个递归基。
  - 根据所要实现的功能，编写函数体。

### 反转链表

- 反转整个链表，分为迭代和递归的方式。

- 对于迭代来说，具体的就是：

  1. 初始化：三个指针，pred指向已经反转部分的头部，cur指向所要反转的部分，succ指向未反转部分的头部。
  2. 反转：其实就是cur.next由指向succ改为指向pred。
  3. 迭代：向后处理未反转的部分，pred移动到cur，cur移动到succ。

- 对于递归来说，具体的就是：

  1. 定义：传入的是要反转的链表的头，返回的是反转后的链表的头。
  2. 递归基：如果传入的是最后一个节点（head.next==null），则直接返回head。
  3. 实现反转功能：
     - 首先，用last接收head.next为头的链表的反转后的新链表头。
     - 此时，head.next指向反转后的新链表尾，需要将head添加到链表尾。
     - 将head.next指向后方未反转的部分。
     - 返回新链表头last。

  ![image-20210110173619558](http://iwehdio.gitee.io/img/my-img/21-01/image-20210110173619558.png)

- 反转链表前n个元素：

  - 需要一个计数变量n，递归基是n=1时直接返回head。
  - 而且，在到达递归基时，还需要记录第n+1个元素的位置succ，让反转后的链表头指向succ。
  - 否则向后调用反转head.next为头的n-1个元素。

- 反转链表的第m到第n个元素：

  - 计数从1开始，所以第一层递归的递归基是，如果m=1，就相当于是反转链表前n个元素。
  - 否则，就相当于以head.next为头，反转链表的第m-1到第n-1个元素。

- K个一组反转链表：

  - 相当于每次都反转链表前K个元素。
  - 反转第1到K个节点时，需要持有第K+1个节点的位置。
  - 递归基是，如果遍历到第K个节点的过程中有null，则返回head。

- 92 反转链表：反转链表的第m到第n个元素。
- 25 K 个一组翻转链表 ：K个一组反转链表。
- 24 两两交换链表中的节点：2个一组反转链表。
- 234 回文链表：反转一半长度的链表。

### 链表迭代/递归

- 2 两数相加  ：有一个链表不为空或者进位不为0就继续迭代。
- 19 删除链表的倒数第N个节点  ：用头哨兵处理退化情况。
- 21 合并两个有序链表 ：退化情况直接连接。
- 23 合并K个升序链表 ：每次分治为两个链表合并，注意递归基有两个。一个是退化情况，区间只有一个链表，另一个是区间边界不合法。
- 61 旋转链表 ：注意旋转k个位置是将指针右移len-k个位置。
- 82 删除排序链表中的重复元素 II  ：递归删除链表头的重复元素。
- 83 删除排序链表中的重复元素：如果需要判断链表中连续两个元素的关系，就需要对该元素和next元素判空。
- 86 分隔链表：简单的迭代，注意保存首尾节点。



## 二叉树

- 226 翻转二叉树：注意在反转时要保存一侧节点的位置。
- 116 填充二叉树节点的右侧指针：原数据默认为null，不需要再次赋值null。
- 114 将二叉树展开为链表：注意要将左右子树都展平；左子树注意要置空。
- 654 最大二叉树：注意递归基是在区间非法时返回null。
- 105 从前序与中序遍历序列构造二叉树：注意区间长度的处理；递归基是在区间非法时返回null。
- 106 从中序与后序遍历序列构造二叉树：与上题类似；都可以使用HashMap优化，以节点的值为索引，键为值。这样可以直接获得索引位置，只需要初始化的时候遍历一次。
- 230 二叉搜索树中第K小的元素：注意只需要中序遍历前k个即可。
- 652 寻找重复的子树：注意序列化时要将每个元素间用逗号分隔。
- 297 二叉树的序列化与反序列化：
  - 序列化和反序列化时用前序遍历比较好理解。
  - StringBuilder的传入int类型的构造是表示容量，而不是初始值，所以需要`new StringBuilder().append(1)`。
  - 全局用一个StringBuilder的效率比较高，方法是用参数传入。

