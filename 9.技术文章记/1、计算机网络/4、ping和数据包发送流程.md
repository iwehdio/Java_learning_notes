学习自：

- [听说你 ping 用的很 6 ？给我图解一下 ping 的工作原理！](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247483999&idx=1&sn=63825d7e7a94c0e03f8f250bbae3e88e&scene=21#wechat_redirect)
- [探究！一个数据包在网络中的心路历程](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247483989&idx=1&sn=7e2ed852770743d3955ef9d5561fcef3&scene=21#wechat_redirect)

## ICMP 协议

- ICMP 是什么？

  - ICMP 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。
  - 网络包在复杂的网络传输环境里，常常会遇到各种问题。当遇到问题的时候，需要传出消息，报告遇到了什么问题，这样才可以调整传输策略，以此来控制整个局面。

- ICMP 功能都有啥？

  - ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。
  - 在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知。比如说是未发现目的主机，即目标不可达。
  - ICMP 的通知消息会使用 IP 进行发送 。

- ICMP 包头格式：

  - ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。

  ![image-20201231204705194](http://iwehdio.gitee.io/img/my-img/21-01/image-20201231204705194.png)

  - ICMP 包头的类型字段，大致可以分为两大类：

    - 一类是用于诊断的查询消息，也就是「查询报文类型」
    - 另一类是通知出错原因的错误消息，也就是「差错报文类型」

    ![image-20201231204822958](http://iwehdio.gitee.io/img/my-img/21-01/image-20201231204822958.png)



### 查询报文类型

- 回送消息 —— 类型 0 和 8：

  - 回送消息用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息， ping 命令就是利用这个消息实现的。

  ![image-20201231204959325](http://iwehdio.gitee.io/img/my-img/21-01/image-20201231204959325.png)

  - 可以向对端主机发送回送请求的消息（ ICMP Echo Request Message ，类型 8 ），也可以接收对端主
    机发回来的回送应答消息（ ICMP Echo Reply Message ，类型 0 ）。

  ![image-20201231205109139](http://iwehdio.gitee.io/img/my-img/21-01/image-20201231205109139.png)

  - 相比原生的 ICMP，这里多了两个字段：
    - 标识符：用以区分是哪个应用程序发 ICMP 包，比如用进程 PID 作为标识符；
    - 序号：序列号从 0 开始，每发送一次新的回送请求就会加 1 ， 可以用来确认网络包是否有丢
      失。
  - 在选项数据中， ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。



### 差错报文类型

- 几个常用的 ICMP 差错报文的例子：

  - 目标不可达消息 —— 类型 为 3
  - 原点抑制消息 —— 类型 4
  - 重定向消息 —— 类型 5
  - 超时消息 —— 类型 11

- 目标不可达消息（Destination Unreachable Message） —— 类型为 3：

  - IP 路由器无法将 IP 数据包发送给目标地址时，会给发送端主机返回一个目标不可达的 ICMP 消息，并在这个消息中显示不可达的具体原因，原因记录在 ICMP 包头的代码字段。
  - 由此，根据 ICMP 不可达的具体消息，发送端主机也就可以了解此次发送不可达的具体原因。

  ![image-20201231205547507](http://iwehdio.gitee.io/img/my-img/21-01/image-20201231205547507.png)

  - 网络不可达代码为 0：
    - IP 地址是分为网络号和主机号的，所以当路由器中的路由器表匹配不到接收方 IP 的网络号，就通过ICMP 协议以网络不可达（ Network Unreachable ）的原因告知主机。
    - 自从不再有网络分类以后，网络不可达也渐渐不再使用了。
  - 主机不可达代码为 1：
    - 当路由表中没有该主机的信息，或者该主机没有连接到网络，那么会通过 ICMP 协议以主机不可达
      （ Host Unreachable ）的原因告知主机。
  - 协议不可达代码为 2：
    - 当主机使用 TCP 协议访问对端主机时，能找到对端的主机了，可是对端主机的防火墙已经禁止 TCP 协议访问，那么会通过 ICMP 协议以协议不可达的原因告知主机。
  - 端口不可达代码为 3：
    - 当主机访问对端主机 8080 端口时，这次能找到对端主机了，防火墙也没有限制，可是发现对端主机没有进程监听 8080 端口，那么会通过 ICMP 协议以端口不可达的原因告知主机。
  - 需要进行分片但设置了不分片位代码为 4：
    - 发送端主机发送 IP 数据报时，将 IP 首部的分片禁止标志位设置为1 。根据这个标志位，途中的路由
      器遇到超过 MTU 大小的数据包时，不会进行片，而是直接抛弃。
    - 随后，通过一个 ICMP 的不可达消息类型，代码为 4 的报文，告知发送端主机。

- 原点抑制消息（ICMP Source Quench Message） —— 类型 4：

  - 在使用低速广域线路的情况下，连接 WAN 的路由器可能会遇到网络拥堵的问题。ICMP 原点抑制消息的目的就是为了缓和这种拥堵情况。
  - 当路由器向低速线路发送数据时，其发送队列的缓存变为零而无法发送出去时，可以向 IP 包的源地址发送一个 ICMP 原点抑制消息。
  - 收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况，从而增大 IP 包的传输间隔，减少网络拥堵的情况。
  - 然而，由于这种 ICMP 可能会引起不公平的网络通信，一般不被使用。

- 重定向消息（ICMP Redirect Message） —— 类型 5：

  - 如果路由器发现发送端主机使用了「不是最优」的路径发送数据，那么它会返回一个 ICMP 重定向消息给这个主机。
  - 在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息告知发送端，让它下次发给另外一个路由器。

- 超时消息（ICMP Time Exceeded Message） —— 类型 11：

  - IP 包中有一个字段叫做 TTL （ Time To Live ，生存周期），它的值随着每经过一次路由器就会减1，直到减到 0 时该 IP 包会被丢弃。
  - 此时，路由器将会发送一个 ICMP 超时消息给发送端主机，并通知该包已被丢弃。
  - 设置 IP 包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免 IP 包无休止地在网络上被转发。
  - 此外，有时可以用 TTL 控制包的到达范围，例如设置一个较小的 TTL 值。



### ping —— 查询报文类型的使用

- ping 的发送和接收过程。同个子网下的主机 A 和 主机 B，主机 A 执行ping 主机 B 后：

  - ping 命令执行的时候，源主机首先会构建一个 ICMP 回送请求消息数据包。

  - ICMP 数据包内包含多个字段，最重要的是两个：

    - 第一个是类型，对于回送请求消息而言该字段为 8 ；
    - 另外一个是序号，主要用于区分连续 ping 的时候发出的多个数据包。

  - 每发出一个请求数据包，序号会自动加 1 。为了能够计算往返时间 RTT ，它会在报文的数据部分插入发送时间。

  - 然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为目的地址，本机 IP 地址作为源地址，协议字段设置为 1 表示是 ICMP 协议，再加上一些其他控制信息，构建一个 IP 数据包。

  - 接下来，需要加入 MAC 头。如果在本地 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC地址，则可以直接使用；如果没有，则需要发送 ARP 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。

    ![image-20201231211029899](http://iwehdio.gitee.io/img/my-img/21-01/image-20201231211029899.png)

  - 主机 B 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。

  - 接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。

  - 在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了ICMP 回送响应消息，则说明目标主机可达。

  - 此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。

  - ping 这个程序是使用了 ICMP 里面的 ECHO REQUEST（类型为 8 ） 和ECHO REPLY （类型为 0）



### traceroute —— 差错报文类型的使用

- 有一款充分利用 ICMP 差错报文类型的应用叫做 traceroute （在UNIX、MacOS中是这个命令，而在Windows中对等的命令叫做 tracert ）。

- traceroute 作用一：

  - traceroute 的第一个作用就是故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。

  - traceroute 的参数指向某个目的 IP 地址：

    ```shell
    traceroute 192.168.1.100
    ```

  - 这个作用是如何工作的呢？

    - 它的原理就是利用 IP 包的生存期限 从 1 开始按照顺序递增的同时发送 UDP 包，强制接收 ICMP 超时消息的一种方法。
    - 比如，将 TTL 设置 为 1 ，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型
      是时间超时。
    - 接下来将 TTL 设置为 2 ，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。
    - 当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。

  - 发送方如何知道发出的 UDP 包是否到达了目的主机呢？

    - traceroute 在发送 UDP 包时，会填入一个不可能的端口号值作为 UDP 目标端口号（大于 3000
      ）。当目的主机，收到 UDP 包后，会返回 ICMP 差错报文消息，但这个差错报文消息的类型是「端口不可达」
    - 所以，当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。

- traceroute 作用二：

  - traceroute 还有一个作用是故意设置不分片，从而确定路径的 MTU。

  - 这么做是为了什么？

    - 这样做的目的是为了路径MTU发现。
    - 有的时候我们并不知道路由器的 MTU 大小，以太网的数据链路上的 MTU 通常是 1500 字节，但是非以太网外的 MTU 值就不一样了，所以我们要知道 MTU 的大小，从而控制发送的包大小。

  - 工作原理如下：

    - 首先在发送端主机发送 IP 数据报时，将 IP 包首部的分片禁止标志位设置为 1。根据这个标志位，
      途中的路由器不会对大数据包进行分片，而是将包丢弃。
    - 随后，通过一个 ICMP 的不可达消息将数据链路上 MTU 的值一起给发送主机，不可达消息的类型为
      「需要进行分片但设置了不分片位」。
    - 发送主机端每次收到 ICMP 差错报文时就减少包的大小，以此来定位一个合适的 MTU 值，以便能到
      达目标主机。

    ![image-20201231212140380](http://iwehdio.gitee.io/img/my-img/21-01/image-20201231212140380.png)



## 当键入网址后，到网页显示，其间发生了什么

![image-20201231212905516](http://iwehdio.gitee.io/img/my-img/21-01/image-20201231212905516.png)

### 孤单小弟HTTP

- 浏览器做的第一步工作是解析 URL

  - 首先浏览器做的第一步工作就是要对 URL 进行解析，从而生成发送给 Web 服务器的请求信息。
  - 让我们看看一条长长的 URL 里的各个元素的代表什么

  ![image-20201231213106306](http://iwehdio.gitee.io/img/my-img/21-01/image-20201231213106306.png)

  ![image-20201231213123874](http://iwehdio.gitee.io/img/my-img/21-01/image-20201231213123874.png)

  - 图中的长长的 URL 实际上是请求服务器里的文件资源。

- 要是上图中的蓝色部分 URL 元素都省略了，那应该是请求哪个文件呢？

  - 当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 /index.html 或者 /default.html这些文件，这样就不会发生混乱了。

- 生产 HTTP 请求信息：

  - 对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP请求消息了。

  ![image-20210104190822387](http://iwehdio.gitee.io/img/my-img/21-01/image-20210104190822387.png)

  ![image-20210104190830784](http://iwehdio.gitee.io/img/my-img/21-01/image-20210104190830784.png)



### 真实地址查询DNS

- 通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。

- 但在发送之前，还有一项工作需要完成，那就是查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。

- 有一种服务器就专门保存了 Web 服务器域名与 IP 的对应关系，它就是 DNS 服务器。

-  详见[DNS的解析流程](https://www.cnblogs.com/iwehdio/p/14209078.html#ip相关协议)，简单来说就是先查询缓存和本地DNS服务器，如果没有后直接访问根域名服务器。通过根域名服务器、顶级域名服务器，找到权威域名服务器，查询后返回IP地址。

### 指南好帮手协议栈

- 通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。
- 协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。

<img src="http://iwehdio.gitee.io/img/my-img/21-01/image-20210104191512934.png" alt="image-20210104191512934" style="zoom: 67%;" />

- 应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，它们两会接受应用层的委托执行收发数据的操作。
- 协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。
- 此外 IP 中还包括 ICMP 协议和 ARP 协议。
  - ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。
  - ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。
- IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。

### 可靠传输TCP

- [TCP的报头格式](https://www.cnblogs.com/iwehdio/p/14213865.html)：
  - 源端口号和目标端口号。
  - 包的序号和确认号。
  - 状态位和窗口大小。
- [TCP的三次握手](https://www.cnblogs.com/iwehdio/p/14213865.html#tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B)，建立连接。
  - 在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为三次握手。
  - 这个所谓的「连接」，只是双方计算机里维护一个状态机。
- 如果 HTTP 请求消息比较长，超过了 MSS 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。
- 据会被以 MSS 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据
- 在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。

### 远程定位 IP

- TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。

- 在 IP 协议里面需要有源地址 IP 和 目标地址 IP：

  - 源地址IP，即是客户端输出的 IP 地址；
  - 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

- 因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 06 （十六进制），表示协议为TCP。

- 假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？

  - 当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。

  - 这个时候就需要根据路由表规则，来判断哪一个网卡作为源地址 IP。在 Linux 操作系统，我们可以使用 `route -n` 命令查看当前系统的路由表。

  - 假设 Web 服务器的目标地址是 192.168.10.200 ：

    ![image-20210104192833717](http://iwehdio.gitee.io/img/my-img/21-01/image-20210104192833717.png)

    1. 首先先和第一条目的子网掩码（ Genmask ）进行 与运算，得到结果为 192.168.10.0 ，但是第一个条目的 Destination 是 192.168.3.0 ，两者不一致所以匹配失败。
    2. 再与第二条目的子网掩码进行 与运算，得到的结果为 192.168.10.0 ，与第二条目的 Destination192.168.10.0 匹配成功，所以将使用 eth1 网卡的 IP 地址作为 IP 包头的源地址。

  - 第三条目比较特殊，它目标地址和子网掩码都是 0.0.0.0 ，这表示默认网关，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器， Gateway 即是路由器的 IP 地址。

### 两点传输  MAC

- MAC 报头格式：
  - MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址和使用的协议信息。
  - 一般在 TCP/IP 通信里，MAC 包头的协议类型只使用：
    - 0800 ： IP 协议
    - 0806 ： ARP 协议
  
- MAC 发送方和接收方如何确认?
  - 发送方的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。
  - 接收方的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。
  - 所以先得搞清楚应该把包发给谁，这个只要查一下路由表就知道了。在路由表中找到相匹配的条目，然后把包发给 Gateway 列中的 IP 地址就可以了。
  
- 既然知道要发给谁，按如何获取对方的 MAC 地址呢？
  - 需要 ARP 协议帮我们找到路由器的 MAC 地址。
  - ARP 协议会在以太网中以广播的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的MAC 地址告诉我”。然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。
  
- 每次都要广播获取，这不是很麻烦吗？
  - 在后续操作系统会把本次查询结果放到一块叫做 ARP 缓存的内存空间留着以后用，不过缓存的时间就几分钟。
  - 在发包时：
    - 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用ARP 缓存中的地址。
    - 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。
  - 查看 ARP 缓存内容：
    - 在 Linux 系统中，可以使用 arp -a 命令来查看 ARP 缓存的内容。
  
- 最后的报文格式：

  ![image-20210104200904159](http://iwehdio.gitee.io/img/my-img/21-01/image-20210104200904159.png)

### 出口  网卡

- IP 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。

- 负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序。

- 网卡驱动从 IP 模块获取到包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。

  - 起始帧分界符是一个用来表示包起始位置的标记
  - 末尾的 FCS （帧校验序列）用来检查包传输过程是否有损坏

  ![image-20210104193522818](http://iwehdio.gitee.io/img/my-img/21-01/image-20210104193522818.png)

- 最后网卡会将包转为电信号，通过网线发送出去。



### 送别者  交换机

- 交换机的设计是将网络包原样转发到目的地。交换机工作在MAC 层，也称为二层网络设备。
- 交换机的包接收操作：
  - 首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。
  - 然后通过包末尾的 FCS 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。
    - 计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；
    - 相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。
    - 因此，和网卡不同，交换机的端口不具有 MAC 地址。
  - 将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。
  - 交换机的 MAC 地址表主要包含两个信息：
    - 一个是设备的 MAC 地址，
    - 另一个是该设备连接在交换机的哪个端口上。
  - 交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。
- 当 MAC 地址表找不到指定的 MAC 地址会怎么样？
  - 地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。
  - 这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。
  - 这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后只有相应的接收者才接收包，而其他设备则会忽略这个包。
  - 如果接收方 MAC 地址是一个广播地址，那么交换机会将包发送到除源端口之外的所有端口。以下两个属于广播地址：
    - MAC 地址中的 FF:FF:FF:FF:FF:FF
    - IP 地址中的 255.255.255.255



### 出境大门  路由器

- 路由器与交换机的区别：

  - 网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。
  - 这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。
  - 不过在具体的操作过程上，路由器和交换机是有区别的。
    - 为路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
    - 而交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。

- 路由器基本原理：

  - 路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。
  - 当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

- 路由器的包接收操作：

  - 首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 FCS进行错误校验。
  - 如果没问题则检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。
  - 总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。

- 查询路由表确定输出端口：

  - 完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。
  - MAC 头部的作用就是将包送达路由器，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。
  - 接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。首先是查询路由表判断转发目标。

  ![image-20210104194505456](http://iwehdio.gitee.io/img/my-img/21-01/image-20210104194505456.png)

  - 假设地址为 10.10.1.101 的计算机要向地址为 192.168.1.100 的服务器发送一个包，这个包先到达图中的路由器。
  - 判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。
  - 每个条目的子网掩码和 192.168.1.100 IP 做 & 与运算后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。
  - 如第二条目的子网掩码 255.255.255.0 与 192.168.1.100 IP 做 & 与运算后，得到结果是192.168.1.0 ，这与第二条目的目标地址 192.168.1.0 匹配，该第二条目记录就会被作为转发目标。
  - 实在找不到匹配路由时，就会选择默认路由，路由表中子网掩码为 0.0.0.0 的记录表示「默认路由」。
  
- 路由器的发送操作：

  - 首先，需要根据路由表的网关列判断对方的地址。
    - 如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。
    - 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。
  - 知道对方的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。
  - 接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写0080 （十六进制）表示 IP 协议。
  - 网络包完成后，接下来会将其转换成电信号并通过端口发送出去。
  - 发送出去的网络包会通过交换机到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。
  - 在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。

### 拆包 服务器 

- 数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。
- 接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。
- 扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。
- 于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。
- 服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。
- HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。并进行之前请求报文类似的操作。
- 客户端把收到的数据包的 HTTP 响应报文，交给浏览器去渲染页面。
- 最后，客户端向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。



