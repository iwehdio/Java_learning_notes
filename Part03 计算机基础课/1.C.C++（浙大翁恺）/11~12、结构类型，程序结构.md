## 1、结构类型

- 常量符号化：

  - 用符号而不是具体的数字来表示程序中的数字。
  - 使用 const 修饰变量。

- 枚举：是一种用户定义的数据类型，用关键字 enum 声明。

  - 格式：`enum 枚举数据名称{名字0, 名字2}`。
  - 枚举类型名字通常并不真的使用，要用的是在大括号里的名字，因为它们就是就是常量符号，它们的类型是int，值则依次从0到n。
  - 当需要一些可以排列起来的常量值时，定义枚举的意义就是给了这些常量值名字。
  - 枚举量可以作为值。
  - 枚举类型可以跟上enum作为类型，即`enum 枚举数据名称`可以被认为是一种数据类型。
  - 但是实际上是以整数来做内部计算和外部输入输出的。
  - 需要遍历所有的枚举量或者需要建立一个用枚举量做下标的数组的时候就很方便了。
  - 声明枚举量的时候可以指定值：`enum COLOR{RED=1，YELLOW，GREEN=5}`。
  - 虽然枚举类型可以当作类型使用，但是实际上很少用。
  - 如果有意义上排比的名字，用枚举比const int方便。
  - 枚举比宏好，因为枚举有int类型。

- 结构：将多个不同类型的数据封装为一个整体。

  - 格式：

    ```c
    //方法1
    struct 结构类型名{
        数据类型1 成员变量1;
        数据类型2 成员变量2;
    };
    //方法2
    struct 结构类型名{
        数据类型1 成员变量1;
        数据类型2 成员变量2;
    }结构体变量1, 结构体变量2;
    
    struct date{
    	int day;
        int month;
        int year;
    };
    ```

  - 定义结构体变量：`struct 结构类型名 结构变量名`。

  - 访问结构变量中的数据：`结构变量名.成员变量`。

  - 结构的初始化：

    ```c
    struct date date1 = {1, 2, 3};
    struct date date2 = {.day=1, .month=2, .year=3};
    ```

  - 要访问整个结构，直接用结构变量的名字。

  - 对于整个结构，可以做赋值、取地址，也可以传递给函数参数或作为返回值。

    - `pl=(struct point){5，10}`。相当于`pl.x=5；pl.y=10`。
    - `pl=p2`。相当于`pl.x=p2.x; pl.y=p2.y`。
    - `int f(struct date d)`。整个结构可以作为参数的值传入函数。这时候是在函数内新建一个结构变量，并复制调用者的结构的值。

  - 和数组不同，结构变量的名字并不是结构变量的地址，必须使用&运算符。`struct date* pDate = &today`。

- 指向结构的指针：

  - 如果要将结构体作为传入函数的参数，一般将指向结构的指针作为传入的参数。

  - 示例：

    ```c
    struct date{
    	int day;
        int month;
        int year;
    }myday;
    
    struct date *p myday;
    (*p).month = 12;
    p->month = 12;
    ```

  - 用符号 -> 表示指针所指的结构变量中的成员。

- 结构作为元素：

  - 结构数组：`struct date dates[]={{1,2,3},{1,2,3}}`。

  - 结构中的结构：

    - 可以通过嵌套操作取得成员变量的成员变量。

    - 示例：

      ```c
      struct rect{
          struct point p1;
          struct point p2;
      };
      struct point{
          int x;
          int y;
      };
      
      struct rect r;
      r.p1.x = 1;
      ```

- 类型定义：

  - C语言提供了一个叫做 typedef 的功能来声明一个已有的数据类型的新名字。就可以用新指定的名字来代替原来的名字使用。

  - 示例：`typedef int length`，此时 length 就是 int 的别名。

  - 为结构体

    ```c
    typedef struct ADate{
        int month;
        int day;
        int year;
    } Date;
    
    Date d = {1, 2, 3};
    ```

- 联合：

  - 格式：

    ```c
    union AnElt{
        int i;
        char c;
    } elt1, elt2;
    
    elt.i = 4;
    ```

  - 存储:

    - 所有的成员共享一个空间。
    - 同一时间只有一个成员是有效的。
    - union的大小是其最大的成员。
    - 初始化：对第一个成员做初始化。

  - 联合的使用：得到一个整数内部的各个字节。

    ```c
    typedef union{
        int i;
        char ch[sizeof(int)];
    } CHI;
    
    int main(int argc, char const *argv[]){
        CHI chi;
        int i;
        chi.i = 1234;
        for(i=0; i<sizeof(int); i++){
            printf("%02hhX", chi.ch[i]);
        }
        return 0;
    }
    ```

##　２、程序结构

- 全局变量：定义在函数外面的变量是全局变量

  - 全局变量具有全局的生存期和作用域。
  - 它们与任何函数都无关，任何函数内部都可以使用它们。

  - 没有做初始化的全局变量会得到0值，指针会得到NULL值。
  - 只能用编译时刻已知的值来初始化全局变量，的初始化发生在main函数之前。
  - 如果函数内部存在与全局变量同名的变量，则全局变量被隐藏。
- 静态本地变量：

  - 在本地变量定义时加上 static 修饰符就成为静态本地变量。
  - 当函数离开的时候，静态本地变量会继续存在并保持其值。
  - 静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开时的值。
  - 静态本地变量实际上是特殊的全局变量，它们位于相同的内存区域。
  - 静态本地变量具有全局的生存期，函数内的局部作用域。
  - static 在这里的意思是局部作用域（本地可访问）。
- 返回指针的函数：
  - 返回本地变量的地址是危险的。
  - 返回全局变量或静态本地变量的地址是安全的。
  - 返回在函数内 malloc 的内存是安全的，但是容易造成问题。
  - 最好的做法是返回传入的指针。
  - 不要使用全局变量来在函数间传递参数和结果。
  - 尽量避免使用全局变量。
  - 使用全局变量和静态本地变量的函数是线程不安全的。

- 编译预处理指令：
  - \#开头的是编译预处理指令。
  - 它们不是C语言的成分，但是C语言程序离不开它们。
- 宏：
  - \#define用来定义一个宏。
  - 格式：`#define<名字><值>`。
  - 示例：`#define PI 3.14159`。
  - 注意没有结尾的分号，因为不是C的语句。
  - 名字必须是一个单词，值可以是各种东西。
  - 在C语言的编译器开始编译之前，编译预处理程序（cpp）会把程序中的名字换成值。
  - 原理是完全的文本替换。
  - 如果一个宏的值中有其他的宏的名字，也是会被替换的。
  - 如果一个宏的值超过--行，最后一行之前的行末需要加 \ 。
  - 宏的值后面出现的注释不会被当作宏的值的一部分。
- 没有值的宏：这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了。
- 预定义的宏：
  - `__LINE__`：行号。
  - `__FILE__`：源代码文件路径。
  - `__DATE__`：编译时的日期。
  - `__TIME__`：编译时的时间。
- 带参数的宏：
  - 示例：`#define cube(x) ((x)(x)*(x))`。
  - 带参数的宏的原则：一切都要括号，整个值要括号，参数出现的每个地方都要括号。
  - 可以带多个参数，也可以组合（嵌套）使用其他宏。





- 多个源代码 .c 文件：

  - main（）里的代码太长了，适合分成几个函数。
  - 一个源代码文件太长了，适合分成几个文件。
  - 两个独立的源代码文件不能编译形成可执行的程序。

- 通过项目链接几个独立的源代码文件：

  - 在Dev C++中新建一个项目，然后把几个源代码文件加入进去。
  - 对于项目，Dev C++的编译会把一个项目中所有的源代码文件都编译后，链接起来。
  - 有的IDE有分开的编译和构建两个按钮，前者是对单个源代码文件编译，后者是对整个项目做链接。
  - 一个.c文件是一个编译单元，编译器每次编译只处理一个编译单元。

- 头文件：

  - 把函数原型放到一个头文件（以.h结尾）中。
  - 在需要调用这个函数的源代码文件（.c文件）中 `#include "头文件名"` 这个头文件，就能让编译器在编译的时候知道函数的原型。
  - \#include是一个编译预处理指令，和宏一样，在编译之前就处理了。
  - 它把那个文件的全部文本内容，原封不动地插入到它所在的地方，所以也不是一定要在.c文件的最前面\#include。
  - \#include有两种形式来指出要插入的文件：
    - `" "` 要求编译器首先在当前目录（.c文件所在的目录）寻找这个文件，如果没有，到编译器指定的目录去找。
    - `< >` 让编译器只在指定的目录去找。
    - 编译器自己知道自己的标准库的头文件在哪里。
    - 环境变量和编译器命令行参数也可以指定寻找头文件的目录。
  - \#include 的误区：
    - \#include不是用来引入库的。
    - stdio.h里只有printf的原型，printf的代码在另外的地方，某个.lib（Windows）或a（Unix）中。
    - 现在的C语言编译器默认会引入所有的标准库。
    - \#include <stdio.h>只是为了让编译器知道printf函数的原型，保证你调用时给出的参数值是正确的类型。
  - 在使用和定义这个函数的地方都应该#include这个头文件。
  - 一般的做法就是任何c都有对应的同名的.h，把所有对外公开的函数的原型和全局变量的声明都放进去。
  - 不对外公开的函数：
    - 在函数前面加上static，就使得它成为只能在所在的编译单元中被使用的函数。
    - 在全局变量前面加上static，就使得它成为只能在所在的编译单元中被使用的全局变量。

- 声明：

  - 在同一项目下的其他文件中要使用本文件下的全局变量。

  - 在 .h 文件中声明：`extern int gAll`。

  - 声明是不产生代码的东西，包括函数原型、变量声明、结构声明、宏声明、枚举声明、类型声明、inline函数。

  - 定义是产生代码的东西。

  - 只有声明可以被放在头文件中，是规则不是法律。

    - 否则会造成一个项目中多个编译单元里有重名的实体。
    - 某些编译器允许几个编译单元中存在同名的函数，或者用weak修饰符来强调这种存在。

  - 同一个编译单元里，同名的结构不能被重复声明。

    - 如果你的头文件里有结构的声明，很难这个头文件不会在一个编译单元里被\#include多次。

    - 所以需要“标准头文件结构”。运用条件编译和宏，保证这个头文件在一个编译单元中只会被#include一次。

    - 以 max.h 文件为例，“标准头文件结构”是指：

      ```c
      #ifndef _MAX_H_
      #define _MAX_H_
      //声明
      #endid
      ```

    - \#pragma once也能起到相同的作用，但是不是所有的编译器都支持。