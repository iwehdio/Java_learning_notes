## 1、概述

- Nosql：

  - 技术演进：

    - 单机MySQL时代，网站的瓶颈在数据量太多、数据索引太大、访问量太大。优化数据库的数据结构和索引，使用文件缓存。
    - Memcached缓存+MySQL+垂直拆分、读写分离，每次查询都读取数据库比较麻烦，希望用缓存减轻数据库压力。
    - 分库分表+水平拆分+MySQL集群，缓存主要解决读的压力，分库分表主要解决写的压力。
    - 数据量太大、变化太快，关系型数据库不够用了。
    - 负载均衡+APP服务器集群+MySQL集群+各种功能服务器。

  - 为什么要用Nosql：数据爆发式增长，关系型数据库难以处理。

  - 什么是Nosql：

    - Nosql=Not only sql。泛指非关系型数据库。
    - 关系型数据库：表格，行和列构筑。
    - 很多数据类型的存储不能按照固定的行列存储。比如使用键值对存储。

  - Nosql特点：

    - 方便扩展，数据之间没有关系。

    - 大数据量、高性能。

    - 缓存是记录级的，是细粒度的缓存，性能比较高。

    - 数据类型是多样型的，不需要事先设计数据库，随取随用。

    - 传统RDBMS和Nosql：

      ```html
      传统RDBMS:
      - 结构化组织
      - SQL
      - 数据和关系都存在单独的表中
      - 数据操作语言，数据定义语言
      - 严格的一致性
      - 基础的事务
      
      Nosql：
      - 没有固定的查询语言
      - 键值对存储、列存储、文档存储、图形数据库
      - 最终一致性
      - CAP定理和BASE（异地多活）
      - 高性能、高可用、高可扩展、高并发
      ```

- Nosql的四大分类：

  - KV键值对存储：redis。
  - 文档型数据库：MongoDB。
  - 列存储数据库：HBase。
  - 图形关系数据库：Neo4j。



- redis：
  - 远程字典服务Remote Dictionary Server。也被称为结构化数据库。
  - 功能：
    - 内存存储、持久化。
    - 效率高，可以用于高速缓存。
    - 发布消息、订阅系统。
    - 地图信息分析。
    - 计时器、计数器。
  - 特性：
    - 多样的数据类型。
    - 持久化。
    - 集群。
    - 事务。
  - 默认端口号6379。
  - Windows下打开客户端和服务端：
    - ping 命令测试连通。
    - set k v/get k v存入和获取值。



## 2、redis基础

- 基础知识：
  - redis默认有16个数据库。默认使用第0个，可以使用`select 编号`切换数据库。
  - 查看数据库大小：`dbsize`。
  - 查看所有的key：`keys *`。
  - 清空全部/当前库：`flushall/flushdb`。
  - redis是单线程的。因为redis是基于内存操作的，CPU不是redis的性能瓶颈，而是机器的内存和网络带宽。
  - 为什么单线程还这么快：redis是将所有的数据全部放在内存中的。避免了多线程导致的CPU上下文切换的资源浪费。使用了多路复用IO。
- redis的作用：数据库、缓存和消息中间件MQ。
- Redis-key的基本命令：
  - 判断某个键是否存在：`exists 键名`。
  - 移除某个键值对：`move 键名 数据库编号`。
  - 设置过期时间：`expire 键名 秒数`。
  - 查看剩余的时间：`ttl 键名`。
  - 查看当前key的类型：`type 键名`。
- 五个基本数据类型：
  - String字符串类型：
    - 存入键值对：`set 键名 值`。
    - 获取键值对：`get 键名`。
    - 给值追加字符串：`append 键名 追加的值`。返回追加后的长度。
    - 获得值的长度：`strlen 键名`。
    - 给数字字符串加一：`incr 键名`。
    - 给数字减一：`decr 键名`。
    - 给数字加n：`incrby 键名 n`。
    - 给数字减n：`decrby 键名 n`。
    - 范围截取字符串：`getrange 键名 start end`。从0开始，双闭区间。
    - 字符替换：`setrange 键名 offset 值`。从偏移量开始进行替换。返回替换后的长度。
    - 设置过期时间：`setex 键名 秒数 值`。
    - 如果不存在再设置：`setnx 键名 值`。存入成功返回值是1，失败返回0。
    - 批量设置：`mset k1 v1 k2 v2`。
    - 批量获取：`mget k1 k2`。
    - 如果不存在再设置：`msetnx k1 v1 k2 v2`。是一个原子性的操作，k1存在k2不存在，k2也无法设置成功。
    - 通过设计key存入对象：`mset user:1:name lisi user:1:age 14`。
    - 先get再set：`getset 键名 值`。如果get不到则返回nil，并且设置新值。
  - String类型的使用场景：
    - 计数器，统计粉丝的数量。
    - 对象缓存存储。
  - List列表类型：
    - 根据元素的出入规则，可以作为队列（阻塞队列）或栈使用。
    - 大部分的List命令都是`l`开头的。
    - 压入列表（插入列表头部，左）：`lpush 键名 值`。
    - 压入列表（插入列表尾部，右）：`rpush 键名 值`。
    - 获取列表中的值：`lrange start end`。
    - 移除列表（从列表头部，左）：`lpop 键名`。返回取出的值。
    - 移除列表（从列表尾部，右）：`rpop 键名`。
    - 根据索引获取值：`lindex 键名 索引`。
    - 删除指定数量的值：`lrem 键名 数量 值`。返回移除的值的数量。
    - 列表长度：`llen 键名`。
    - 列表截断：`ltrim start end`。移除两侧的元素。
    - 移除列表最后一个元素并且添加到一个新的列表：`rpoplpush 原键名 新键名`。还有其他不同的r/l组合。
    - 判断列表中是否有值：`exists 键名`，返回0则没有值。
    - 根据索引更新值：`lset 键名 索引 值`。列表必须已经存在，而且不能设置越界的索引。
    - 插入值：`linsert 键名 before/after 基准的值 新的值`。返回插入后的列表长度。
  - List类型的实现：
    - redis中的列表实际上是一个链表。
    - 在两边插入或者改动值，效率最高。
  - Set集合类型：
    - Set中的值是不能重复的，是无序的。
    - 大部分的Set命令都是`s`开头的。
    - 往集合中添加值：`sadd 键名 值`，返回1添加成功，返回0添加失败。
    - 集合中的所有值：`smembers 键名`。
    - 判断集合中有没有此元素：`sismember 键名 值`，返回0说明有，返回1说明没有。
    - 获取集合大小：`scard 键名`。
    - 从集合中移除元素：`srem 键名 值`。
    - 随机抽取一个元素：`srandmember 键名 取出的数量`。
    - 随机删除元素：`spop 键名`，返回移除的元素。
    - 将一个指定的值移动到另外的集合中：`smove 原键名 新键名 值`，返回1表示成功，0表示失败。
    - 取差集：`sdiff 键名1 键名2`。
    - 取交集：`sinter 键名1 键名2`。
    - 取并集：`sunion 键名1 键名2`。
  - Set类型的使用场景：
    - 将一个用户的粉丝放在集合中，交集作为共同关注的实现。
  - Hash哈希类型：
    - 可以认为是一个map集合，即key-map结构。
    - 大部分的Hash命令都是`h`开头的。
    - 往哈希中添加值：`hset 键名 字段名 值`，返回1成功，0失败。
    - 从哈希中获取值：`hget 键名 字段名`。
    - 批量添加值：`hmset 键名 k1 v1 k2 v2`。
    - 批量获取值：`hmget 键名 k1 k2`。
    - 获取所有的数据：`hgetall 键名。`
    - 删除操作：`hdel 键名 字段名`，返回1成功，0失败。
    - 获取哈希的大小：`hlen 键名`。
    - 判断哈希中的某个字段是否存在：`hexists 键名 字段名`，返回1存在，0不存在。
    - 只获取哈希的所有字段：`hkeys 键名`。
    - 只获取哈希的所有值：`hvals 键名`。
    - 使字段对应的值自增：`hincrby 键名 字段名 步长`，返回自增的结果。
    - 如果不存在则设置：`hsetnx 键名 字段名 值`。
  - Hash类型的使用场景：
    - 存入变更的数据，比如存入一个对象的数据。
  - Zset有序集合类型：
    - 在Set的基础上，增加了一个值作为分数。
    - 添加操作：`zadd 键名 分数 值`，返回1添加成功，0失败。
    - 根据分数排序排序：`zrangebyscore 键名 -inf +inf `，最小最大值设置为无穷。加`withscores`可以输出分数。
    - 倒序输出：`zrevrange 键名 start end`。
    - 输入所有元素：`zrange 键名 start end`。
    - 移除元素：`zrem 键名 值 `，返回1移除成功。
    - 集合的大小：`zcard 键名`。
    - 获取指定分数区间的元素数量：`zcount 键名 min max`，返回元素数量。
  - Zset类型应用场景：
    - 存储班级成绩表、工资表排序。
    - 设置不同消息的权重，显示重要类型。
    - 排行榜应用实现。



- 三种特殊数据类型：
  - geospatial地理位置：
    - 一般会下载城市数据，通过程序一次性导入。有效的经度从-180道180，有效的纬度从-85到85。
    - geo的底层实现是Zset，可以用Zset的命令操作geo。
    - 添加地理位置：`geoadd 键名 经度 纬度 字段名 `，返回添加成功的数量。
    - 从指定的键中获取定位的经纬度：`geopos 键名 字段名`。
    - 两个定位之间的距离：`geodist 键名 字段1 字段2 `，默认返回的单位是米。
    - 以给定定位为中心，找出半径内的元素：`georadius 键名 经度 纬度 半径`。
    - 以给定元素为中心，找出半径内的元素：`georadiusbymember 键名 字段名 半径`。
    - 返回位置的geohash表示：`geohash 键名 字段名`。
  - geospatial类型的应用场景：
    - 朋友定位、附近的人。
    - 打车距离、城市经度纬度查询。
  - hyperloglog基数统计：
    - 基数：不重复的元素个数，数字非常大时可以接受误差（0.81%）。
    - 优点：占用的内存是固定的12KB，相比使用Set集合节省内存。
    - 添加元素：`pfadd 键名 元素`，返回1表示成功。
    - 统计元素个数：`pfcount 键名`。
    - 合并操作：`pfmerge 目标键名 源键名1 源键名2`。
  - hyperloglog类型应用场景：
    - 一个人访问一个网站多次，但还是算作一个人。
  - bitmap位图数据：
    - 设置值：`setbit 键名 offset 值`。值只能存0或1。返回0表示新建，1表示覆盖。
    - 查看值：`getbit 键名 offset`。
    - 统计1的数量：`bitcount 键名 start end`。
  - bitmap类型应用场景：
    - 存储打卡信息。
    - 只有两个状态的情况。