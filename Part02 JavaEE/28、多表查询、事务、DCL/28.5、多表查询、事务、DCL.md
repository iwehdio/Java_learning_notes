## 28.5、多表查询、事务、DCL

## 1、事务

- 事务：如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。

- 事务中的操作：

  1. 开启事务：`start transaction`。在事务的所有步骤开始前开启。
  2. 回滚：`rollback`。如果有一个步骤出问题则回滚，将数据库还原到开启事务时的状态。
  3. 提交事务：`commit`。如果没有出现问题，则正常运行，提交事务。如果没有提交事务，数据只会被暂时更改，关闭进程后会默认回滚。

- MySQL 数据库中事务默认自动提交，一条 DML（增删改） 语句会提交一次事务。如果是手动开启事务的，也必须手动提交。

- 查看默认提交方式：`select @@autocommit`，1代表自动提交，0代表手动提交。`set @@autocommit = 0`，可更改为默认手动提交。

- 事务的四大特征：

  - 原子性：不可分割的的最小操作单位，要么同时成功，要么同时失败。
  - 持久性：事务一旦提交或者回滚，数据库的会持久化保存数据。
  - 隔离性：多个事务之间，希望是相互独立的。
  - 一致性：事务操作前后，数据总量不变。

- 事务的隔离级别：

  - 多个事务之间是隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的事务隔离级别可以解决这些问题。

  - 会存在那些问题：

    1. 脏读：一个事务，读取到了另一个事务中没有提交的数据。
    2. 不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样。
    3. 幻读：一个事务操作（DML）数据表中的所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。

  - 隔离级别：

    1. `read uncommitted`：读未提交。可能会产生：脏读、不可重复读、幻读。
    2. `read committed`：读已提交。可能会产生：不可重复读、幻读。（Oracle默认）
    3. `repeatable read`：可重复读。可能会产生：幻读。（MySQL默认）
    4. `serializable`：串行化，相当于对表加锁，同一时间只能有一个事务对这张表进行操作或查询。不会出现任何问题。

    - 隔离级别从小到大安全性越来越高，但是效率越来越低。

  - 数据库查询隔离级别：`select @@tx_isolation`。

  - 数据库设置隔离级别：`set global transaction isolation level 隔离级别`。

## 2、DCL

- 管理用户：

  - 查询用户：切换到 mysql 数据库，查询其中的 user 表。
  - 创建用户：`create user '用户名'@'主机名' identified by '密码'`。
    - localhost 表示本地主机，% （通配符）表示任意远程主机。
  - 删除用户：`drop user '用户名'@'主机名' `。
  - 修改密码：`update user set password = password('密码') where user='用户名' ` 或 `set password for '用户名'@'主机名'=password('密码')`。
  - 修改 root 用户密码：
    1. 在 cmd 中停止 mysql 服务：`net stop mysql`（管理员权限）。
    2. 使用无验证方式启动 mysql 服务：`mysqld --skip-grant-tables`。
    3. 打开新的 cmd 窗口，输入 mysql 启动。
    4. 使用前述方式更改密码。
    5. 手动结束 mysqld 进程。

- 权限管理：

  - 查询权限：`show grants for '用户名'@'主机名'`。

  - 授予权限：`grant 权限列表 on 数据库名.表名 to '用户名'@'主机名'`。

    - 权限列表包括 select、delete、update 等。

    - 授予所有权限：`grant all on *.* to '用户名'@'主机名'`。

  - 撤销权限：`revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名' `。

